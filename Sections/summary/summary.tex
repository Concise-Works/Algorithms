\vfill

\begin{center}
\textit{This page is left intentionally blank.}
\end{center}
\vfill
\newpage

\noindent
\textbf{Growth Rates}: $1 < \log n < n < n \log n < n^2 < n^3 < 2^n < n! < n^n$ (\ref{thm:growth_rates}) | \textbf{(htbl)}:= hash-table\\
\textbf{$O$(Upper Bound)}: $f(n) < g(n)\implies $lim$_{n\to\infty}\frac{f(n)}{g(n)}=0$ (\ref{def:bigO}) \hspace{5.47em}| \textbf{(conn.)}:= connected\\
\textbf{$\Omega$(Lower Bound)}: $f(n) > g(n)\implies $lim$_{n\to\infty}0<\frac{f(n)}{g(n)}$ (\ref{def:bigOmega})\\
\textbf{$\Theta$(Upper \& Lower Bound)}: $f(n) = g(n)\implies 0<\frac{f(n)}{g(n)}<\infty$ (\ref{def:bigTheta})\\
\noindent\rule{\textwidth}{0.4pt}
\textbf{Interval Scheduling}: sort by finish time ascending order, choose next compatible job (\ref{thm:eft})\\
\textbf{Interval Partition}: sort by start time, find next available resource (\ref{theo:est})\\
\textbf{Min Lateness}: sort by finish time, take next available job (\ref{theo:late})\\
\noindent\rule{\textwidth}{0.4pt}

\vspace{.5em}
\noindent

\begin{minipage}{0.45\textwidth}
\textbf{Master Method:}\\

\vspace{-.5em}
\noindent
$T(n) = \textcolor{red}{a}T\left(\dfrac{n}{\textcolor{blue}{b}}\right) + f(n^{\textcolor{OliveGreen}{d}}):$ (\ref{theo:master})\\
$\textcolor{OliveGreen}{d} > \log_{\textcolor{blue}{b}} \textcolor{red}{a} \implies T(n) = \Theta(n^{\textcolor{OliveGreen}{d}})$\\
$\textcolor{OliveGreen}{d} < \log_{\textcolor{blue}{b}} \textcolor{red}{a} \implies T(n) = \Theta(n^{\log_{\textcolor{blue}{b}} \textcolor{red}{a}})$\\
$\textcolor{OliveGreen}{d} = \log_{\textcolor{blue}{b}} \textcolor{red}{a} \implies T(n) = \Theta(n^{\log_{\textcolor{blue}{b}} \textcolor{red}{a}} \log n)$\\
\end{minipage}
\hfill
\begin{minipage}{0.45\textwidth}
\textbf{Big-Os:}\\
\textbf{logs:} $\log n = O(\sqrt{n}) = O(n)$(\ref{proof:logn})(\ref{proof:logn})\\
\textbf{edges:} $m \leq O(n^2)$ typically $m<n$ (\ref{def:adj_list})\\
\textbf{long $(\times,\div)$ :} $O(n^2)$ (\ref{theo:basic-arithmetic})\\
\textbf{Karatsuba:} $O(n^{\log_2 3})\approx O(n^{1.59})$ (\ref{page:karatsuba})\\
\textbf{sorting:} $O(n\log n)$ (\ref{proof:merge})\\
\end{minipage}
\noindent\rule{\textwidth}{0.4pt}
\textbf{BFS}: $O(n+m)$ (\ref{sec:bfs_dfs}). Siblings before children, shortest paths tree.\\
\textbf{DFS}: $O(n+m)$ (\ref{sec:bfs_dfs}). Children before siblings, not longest paths.\\
\textbf{Heap}: sorting $O(n\log n)$, operations $O(\log n)$ except for extract-min $O(1)$ (\ref{sec:priority}).\\
\textbf{Dijkstra}:$O((n+m)\log n)$;$O(m \log n)$(conn.);$O(n^2)$(htbl). Min paths from $s$ (no neg.paths) (\ref{sec:dstra}).\\
\textbf{Prim's}: $O(m\log n)$. $O(n^2)$(htbl). MST, dijkstra like routine, (\ref{theo:prim}).\\
\textbf{Kruskal's}: $O(m \log n)$ or $O(m \log m)$. MST, sort \& pick edges ascending, union-find (\ref{theo:kruskal}).\\
\textbf{Bellman-Ford}: $O(nm)$. Shortest paths from $s$ via relax rounds on $n$ (no negatives cycles) (\ref{theo:bellman}).\\
\textbf{Ford-Fulkerson}: $O(mnC)$, $C:=$ largest capacity, finds max flow (\ref{theo:bellman}).\\
\noindent\rule{\textwidth}{0.4pt}
\textbf{P:} decision problems solvable in polynomial time (\ref{sec:hard}).\\
\textbf{NP:} decision problems verifiable in polynomial time. E.g., ``is this path $\geq k$.''\\
\textbf{NP-Complete:} a problem $X$ that if solved in polynomial time, all NP problems may use it as a subroutine to be solved in polynomial time.\\
\textbf{NP-Hard:} an NP-Complete problem which may not be in NP or have a solution.\\
\textbf{EXP:} decision problems solvable in exponential time.\\
\noindent\rule{\textwidth}{0.4pt}
\textbf{Substitution Examples:} (\ref{theo:iterative})

\vspace{-.5em}
\begin{itemize}
    \item[(a)] $2^{k}\ T \left(\dfrac{n}{3^k} \right)+k \Theta(n)$: $2^{log_3n}\ T \left(\dfrac{n}{3^{log_3n}} \right)+log_3n \Theta(n)$.
    Simplifying: $2^{log_3n}+\Theta(1)+nlog_3n$. Then apply the identity $a^{log_bc}=c^{log_ba}$.
    Then $n^{log_32}+nlog_3n$. We know $log_3n=O(n)$, so $n^{log_32}+nO(n)=n^{log_32}+O(n)$.
    Then $n^{log_32}<O(n)$, as $log_32$ must be some fraction rooting $n$. hence $O(n)$

    \item[(b)] $4^{k}\ T \left(\dfrac{n}{3^k} \right)+k \Theta(n)$: $4^{log_3n}+n^{log_3n}=n^{log_34}+O(n)$. Then $O(n^{log_34})$ as $log_34>1$
    \item[(c)]  $9^{k}\ T \left(\dfrac{n}{3^k} \right)+k \Theta(n^2)$: $9^{log_3n}=3^{2\cdot\log_3n}=3^{\log_3n^2}=n^2$.
    So $n^2+n^2log_3n = O(n^2log_3n) $
\end{itemize}
\noindent\rule{\textwidth}{0.4pt}
\textbf{Log Rules:} $\log_2(8)=3,\log_8(2)=\frac{1}{3},\log_2(\frac{1}{8})=-3, \log_8(\frac{1}{2})=-\frac{1}{3},n^{\log_ba}=a^{\log_bn},n^{\log_na}=a$\\

\vspace{-1em}
\noindent
$\log(ba)=\log b+\log a,\log(\frac{b}{a})=\log b-\log a,\log_ba=\frac{\log a}{\log b},2\log a= \log a^2$ (\ref{thm:logrules}).

\newpage 

\noindent
\textbf{Dynamic Programming}:\\

\noindent
\textbf{Weighted Int. Sched.} ($O(n\log n)$): sort by finish time, find next compatible job (\ref{sec:WIS})\\
 \begin{align*}
     OPT(j) =
    \begin{cases}
        0 & \text{if $j=0$}\\
        max\{\underbracket{v_j+OPT(p(j))}_{\text{build solution}}, \underbracket{OPT(j-1)}_{\text{next solution}}\} & \text{else}
    \end{cases}
\end{align*}

\noindent
\textbf{Subset Sum}($O(nT)$)(\ref{sec:subset}): 
\begin{align*}
    OPT(i, T) =
    \begin{cases}
        0 & \text{if $T=0$}\\
        OPT(i-1, T) & \text{if $S_i > T$}\\
        max\{\underbracket{OPT(i-1, T)}_{\text{next solution}}, \underbracket{S_i+OPT(i-1, T-S_i)}_{\text{build solution}}\} & \text{else}
    \end{cases}
\end{align*}

\noindent
\textbf{Knapsack}($O(nW)$)(\ref{sec:knapsack}):
\begin{align*}
    OPT(i, w) =
    \begin{cases}
        0 & \text{if $i==0$}\\
        OPT(i-1, w) & \text{if $w_i > w$}\\
        max\{\underbracket{OPT(i-1, w)}_{\text{next solution}}, \underbracket{v_i+OPT(i-1, w-w_i)}_{\text{build solution}}\} & \text{else}
    \end{cases}
\end{align*}

\noindent
\textbf{Knapsack Unbounded (unoptimal)}($O(nW^2)$)(\ref{sec:unop_unbounded}):
\begin{align*}
    OPT(i, w) =
    \begin{cases}
        0 & \text{if $i==0$}\\
        OPT(i-1, w) & \text{if $w_i > w$}\\
        {\displaystyle \max_{j = 0, \dots, \infty}}\{\underbracket{OPT(i-1, w)}_{\text{next solution}}, \underbracket{j\cdot v_i+OPT(i-1, w-j\cdot w_i)}_{\text{build solution}}\} & \text{else}
    \end{cases}
\end{align*}

\noindent
\textbf{Knapsack Unbounded (optimal)}($O(nW)$)(\ref{sec:unbounded}):
\[
\text{OPT}(i, w) = 
\begin{cases} 
    0 & \text{if } i = 0, \\
    \text{OPT}(i-1, w) & \text{if } w_i > w, \\
    \max\left(\text{OPT}(i-1, w), v_i + \text{OPT}(i, w - w_i)\right) & \text{otherwise.}
\end{cases}
\]

\newpage

\noindent
(\ref{sec:subset})
\begin{Func}[Backtracking Subset Sum - \textit{Backtrack()}]

    \vspace{-.5em}
    \begin{algorithm}[H]
        \SetKwProg{Fn}{Function}{:}{}
        $i \gets 0$; $t \gets T$; $S \gets \{\}$; \tcp{$S$ is our set of jobs}
        $Backtrack(OPT, i, t)$\;
        \Fn{\textit{Backtrack}(OPT, i, t)}{
            \tcp{Where $OTP.length$ is the number of rows}
            \While{$i < OPT.length$}{
                \If{$OPT[i][t] > OPT[i+1][t]$}{
                    $S \gets S \cup \{S[i]\}$\;
                    $t \gets t-S[i]$\;
                }
                $i \gets i+1$\;
            }
            \Return $S$\;
        }
    \end{algorithm}
    \noindent
    \rule{\textwidth}{0.4pt}
    \textbf{Time Complexity:} $O(n)$. At most, iterate through all $n$ jobs, and add them to our set $S$.
\end{Func}
(\ref{sec:unbounded})
\begin{Func}[Traceback Solution for Unbounded Knapsack - \textit{Traceback()}]

    \vspace{-.5em}
    \begin{algorithm}[H]
        \SetKwProg{Fn}{Function}{:}{}
        $i \gets n$ \tcp{Start from the last item}
        $w \gets W$ \tcp{Start from the maximum weight}
        $sol \gets \emptyset$ \tcp{Initialize the solution set}
        
        \While{$i > 0$ \textbf{and} $w > 0$}{
            \If{$w \geq w_i$ \textbf{and} $(v_i + M[i][w - w_i] > M[i-1][w])$}{
                $sol.\textit{add}(i)$ \tcp{Add item $i$ to the solution}
                $w \gets w - w_i$ \tcp{Reduce the weight}
            }
            \Else{
                $i \gets i - 1$ \tcp{Move to the previous item}
            }
        }
        \Return $sol$\;
    \end{algorithm}
    
    \noindent
    \rule{\textwidth}{0.4pt}
    \textbf{Time Complexity:} $O(n + W)$, as we traverse the DP table in reverse order.
\end{Func}
\noindent



