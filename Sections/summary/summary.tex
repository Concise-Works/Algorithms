\vfill

\begin{center}
\textit{This page is left intentionally blank.}
\end{center}
\vfill
\newpage

\noindent
\textbf{Growth Rates}: $1 < \log n < n < n \log n < n^2 < n^3 < 2^n < n! < n^n$ (\ref{thm:growth_rates}) | \textbf{(htbl)}:= hash-table\\
\textbf{$O$(Upper Bound)}: $f(n) < g(n)\implies $lim$_{n\to\infty}\frac{f(n)}{g(n)}=0$ (\ref{def:bigO}) \hspace{5.47em}| \textbf{(conn.)}:= connected\\
\textbf{$\Omega$(Lower Bound)}: $f(n) > g(n)\implies $lim$_{n\to\infty}0<\frac{f(n)}{g(n)}$ (\ref{def:bigOmega})\\
\textbf{$\Theta$(Upper \& Lower Bound)}: $f(n) = g(n)\implies 0<\frac{f(n)}{g(n)}<\infty$ (\ref{def:bigTheta})\\
\noindent\rule{\textwidth}{0.4pt}
\textbf{Interval Scheduling}: sort by finish time ascending order, choose next compatible job (\ref{thm:eft})\\
\textbf{Interval Partition}: sort by start time, find next available resource (\ref{theo:est})\\
\textbf{Min Lateness}: sort by finish time, take next available job (\ref{theo:late})\\
\noindent\rule{\textwidth}{0.4pt}

\vspace{.5em}
\noindent

\begin{minipage}{0.45\textwidth}
\textbf{Master Method:}\\

\vspace{-.5em}
\noindent
$T(n) = \textcolor{red}{a}T\left(\dfrac{n}{\textcolor{blue}{b}}\right) + f(n^{\textcolor{OliveGreen}{d}}):$ (\ref{theo:master})\\
$\textcolor{OliveGreen}{d} > \log_{\textcolor{blue}{b}} \textcolor{red}{a} \implies T(n) = \Theta(n^{\textcolor{OliveGreen}{d}})$\\
$\textcolor{OliveGreen}{d} < \log_{\textcolor{blue}{b}} \textcolor{red}{a} \implies T(n) = \Theta(n^{\log_{\textcolor{blue}{b}} \textcolor{red}{a}})$\\
$\textcolor{OliveGreen}{d} = \log_{\textcolor{blue}{b}} \textcolor{red}{a} \implies T(n) = \Theta(n^{\log_{\textcolor{blue}{b}} \textcolor{red}{a}} \log n)$\\
\end{minipage}
\hfill
\begin{minipage}{0.45\textwidth}
\textbf{Big-Os:}\\
\textbf{logs:} $\log n = O(\sqrt{n}) = O(n)$(\ref{proof:logn})(\ref{proof:logn})\\
\textbf{edges:} $m \leq O(n^2)$ typically $m<n$ (\ref{def:adj_list})\\
\textbf{long $(\times,\div)$ :} $O(n^2)$ (\ref{theo:basic-arithmetic})\\
\textbf{Karatsuba:} $O(n^{\log_2 3})\approx O(n^{1.59})$ (\ref{page:karatsuba})\\
\textbf{sorting:} $O(n\log n)$ (\ref{proof:merge})\\
\end{minipage}
\noindent\rule{\textwidth}{0.4pt}
\textbf{BFS}: $O(n+m)$ (\ref{sec:bfs_dfs}). Siblings before children, shortest paths tree.\\
\textbf{DFS}: $O(n+m)$ (\ref{sec:bfs_dfs}). Children before siblings, not longest paths.\\
\textbf{Heap}: sorting $O(n\log n)$, operations $O(\log n)$ except for extract-min $O(1)$ (\ref{sec:priority}).\\
\textbf{Dijkstra}:$O((n+m)\log n)$;$O(m \log n)$(conn.);$O(n^2)$(htbl). Min paths from $s$ (no neg.paths) (\ref{sec:dstra}).\\
\textbf{Prim's}: $O(m\log n)$. $O(n^2)$(htbl). MST, dijkstra like routine, (\ref{theo:prim}).\\
\textbf{Kruskal's}: $O(m \log n)$ or $O(m \log m)$. MST, sort \& pick edges ascending, union-find (\ref{theo:kruskal}).\\
\textbf{Bellman-Ford}: $O(nm)$. Shortest paths from $s$ via relax rounds on $n$ (no negatives cycles) (\ref{theo:bellman}).\\
\textbf{Ford-Fulkerson}: $O(mnC)$, $C:=$ largest capacity, finds max flow (\ref{theo:bellman}).\\
\noindent\rule{\textwidth}{0.4pt}
\textbf{P:} decision problems solvable in polynomial time (\ref{sec:hard}).\\
\textbf{NP:} decision problems verifiable in polynomial time. E.g., ``is this path $\geq k$.''\\
\textbf{NP-Complete:} a problem $X$ that if solved in polynomial time, all NP problems may use it as a subroutine to be solved in polynomial time.\\
\textbf{NP-Hard:} an NP-Complete problem which may not be in NP or have a solution.\\
\textbf{EXP:} decision problems solvable in exponential time.\\
\noindent\rule{\textwidth}{0.4pt}
\textbf{Substitution Examples:} (\ref{theo:iterative})

\vspace{-.5em}
\begin{itemize}
    \item[(a)] $2^{k}\ T \left(\dfrac{n}{3^k} \right)+k \Theta(n)$: $2^{log_3n}\ T \left(\dfrac{n}{3^{log_3n}} \right)+log_3n \Theta(n)$.
    Simplifying: $2^{log_3n}+\Theta(1)+nlog_3n$. Then apply the identity $a^{log_bc}=c^{log_ba}$.
    Then $n^{log_32}+log_3(n)n$. Then,$log_3(n)n=log_3(n^2)=O(n)$.
    Then $n^{log_32}<O(n)$, as $log_32$ must be some fraction rooting $n$. hence $O(n)$

    \item[(b)] $4^{k}\ T \left(\dfrac{n}{3^k} \right)+k \Theta(n)$: $4^{log_3n}+n^{log_3n}=n^{log_34}+O(n)$. Then $O(n^{log_34})$ as $log_34>1$
    \item[(c)]  $9^{k}\ T \left(\dfrac{n}{3^k} \right)+k \Theta(n^2)$: $9^{log_3n}=3^{2\cdot\log_3n}=3^{\log_3n^2}=n^2$.
    So $n^2+n^2log_3n = O(n^2log_3n) $
\end{itemize}
\noindent\rule{\textwidth}{0.4pt}
\textbf{Log Rules:} $\log_2(8)=3,\log_8(2)=\frac{1}{3},\log_2(\frac{1}{8})=-3, \log_8(\frac{1}{2})=-\frac{1}{3},n^{\log_ba}=a^{\log_bn},n^{\log_na}=a$\\

\vspace{-1em}
\noindent
$\log(ba)=\log b+\log a,\log(\frac{b}{a})=\log b-\log a,\log_ba=\frac{\log a}{\log b},2\log a= \log a^2$ (\ref{thm:logrules}).

\newpage 

\noindent
\textbf{Dynamic Programming}:\\

\noindent
\textbf{Weighted Int. Sched.} ($O(n\log n)$): sort by finish time, find next compatible job (\ref{sec:WIS})\\
 \begin{align*}
     OPT(j) =
    \begin{cases}
        0 & \text{if $j=0$}\\
        max\{\underbracket{v_j+OPT(p(j))}_{\text{build solution}}, \underbracket{OPT(j-1)}_{\text{next solution}}\} & \text{else}
    \end{cases}
\end{align*}

\noindent
\textbf{Subset Sum}($O(nT)$)(\ref{sec:subset}): 
\begin{align*}
    OPT(i, T) =
    \begin{cases}
        0 & \text{if $T=0$}\\
        OPT(i-1, T) & \text{if $S_i > T$}\\
        max\{\underbracket{OPT(i-1, T)}_{\text{next solution}}, \underbracket{S_i+OPT(i-1, T-S_i)}_{\text{build solution}}\} & \text{else}
    \end{cases}
\end{align*}

\noindent
\textbf{Knapsack}($O(nW)$)(\ref{sec:knapsack}):
\begin{align*}
    OPT(i, w) =
    \begin{cases}
        0 & \text{if $i==0$}\\
        OPT(i-1, w) & \text{if $w_i > w$}\\
        max\{\underbracket{OPT(i-1, w)}_{\text{next solution}}, \underbracket{v_i+OPT(i-1, w-w_i)}_{\text{build solution}}\} & \text{else}
    \end{cases}
\end{align*}

\noindent
\textbf{Knapsack Unbounded (unoptimal)}($O(nW^2)$)(\ref{sec:unop_unbounded}):
\begin{align*}
    OPT(i, w) =
    \begin{cases}
        0 & \text{if $i==0$}\\
        OPT(i-1, w) & \text{if $w_i > w$}\\
        {\displaystyle \max_{j = 0, \dots, \infty}}\{\underbracket{OPT(i-1, w)}_{\text{next solution}}, \underbracket{j\cdot v_i+OPT(i-1, w-j\cdot w_i)}_{\text{build solution}}\} & \text{else}
    \end{cases}
\end{align*}

\noindent
\textbf{Knapsack Unbounded (optimal)}($O(nW)$)(\ref{sec:unbounded}):
\[
\text{OPT}(i, w) = 
\begin{cases} 
    0 & \text{if } i = 0, \\
    \text{OPT}(i-1, w) & \text{if } w_i > w, \\
    \max\left(\text{OPT}(i-1, w), v_i + \text{OPT}(i, w - w_i)\right) & \text{otherwise.}
\end{cases}
\]

\newpage

(\ref{fig:fib})
\begin{Func}[Slow Fibonacci Sequence - \textit{Fib()}]
    \noindent
    \textbf{Input:} $n$ the index of the Fibonacci sequence we wish to compute.\\
    \textbf{Output:} $F_n$ the $n_{th}$ Fibonacci number.\\

    \vspace{-.5em}
    \begin{algorithm}[H]
        \SetAlgoLined
        \SetKwProg{Fn}{Function}{:}{\KwRet{}}
        \Fn{\textit{Fib}($n$)}{
            \If{$n \leq 1$}{
                \textbf{return} $n$\;
            }
            \Else{
                \textbf{return} $\textit{Fib}(n-1)+\textit{Fib}(n-2)$\;
            }
        }
    \end{algorithm}
    \noindent
    \rule{\textwidth}{0.4pt}
    \textbf{Time Complexity:} $O(2^n)$. $T(n)=T(n-1)+T(n-2)+O(1)$, Theorem (\ref{theo:master}).
\end{Func}

\begin{Func}[Memo Fibonacci Sequence - \textit{Fib()}]

    \textbf{Input:} $n$ the index of the Fibonacci sequence we wish to compute.\\
    \textbf{Output:} $F_n$ the $n_{th}$ Fibonacci number.\\

    \vspace{-.5em}
    \begin{algorithm}[H]
        \SetAlgoLined
        \SetKwProg{Fn}{Function}{:}{\KwRet{}}
        $F[\ ]$; \tcp{Table to store Fibonacci numbers}
        \Fn{\textit{Fib}($n$)}{
            \If{$n \leq 1$}{
                \textbf{return} $n$\;
            }
            \Else{
                \If{$F[n]$ is not defined}{
                    $F[n] = \textit{Fib}(n-1)+\textit{Fib}(n-2)$\;
                }
                \textbf{return} $F[n]$\;
            }
        }
    \end{algorithm}
    \noindent
    \rule{\textwidth}{0.4pt}
    \textbf{Time Complexity:} $O(n)$.
    \textbf{Space Complexity:} $O(n)$.
\end{Func}

\begin{Func}[Bottom-Up Fibonacci Sequence - \textit{Fib()}]

    \vspace{-.5em}
    \begin{algorithm}[H]
        \SetAlgoLined
        \SetKwProg{Fn}{Function}{:}{}
        $F[0] \gets 0$; $F[1] \gets 1$; \tcp{Base cases (array of size $n+1$)}
        \For{$i \gets 2$ \KwTo $n$}{
            $F[i] \gets F[i-1]+F[i-2]$\;
        }
        \textbf{return} $F[n]$\;
    \end{algorithm}
    \noindent
    \rule{\textwidth}{0.4pt}
    \textbf{Time Complexity:} $O(n)$.
\end{Func}

\newpage 

(\ref{func:wis})
\begin{Func}[Bottom-Up Weighted Interval Scheduling - \textit{OPT()}]

    \vspace{-.5em}
    \begin{algorithm}[H]
        \SetAlgoLined
        \SetKwProg{Fn}{Function}{:}{}
        Sort jobs by finish time; \tcp{$O(n\log n)$}
        Compute all $p(1),\dots,p(n)$; \tcp{$O(n)$}
        $OPT[0] \gets 0$; \tcp{Base case (array of size $n+1$)}
        \For{$j \gets 1$ \KwTo $n$}{
            $OPT[j] \gets max\{v_j+OPT[p(j)], OPT[j-1]\}$\;
        }
        \textbf{return} $OPT[n]$\;
    \end{algorithm}
    \noindent
    \rule{\textwidth}{0.4pt}
    \textbf{Time Complexity:} $O(n\log n)$. We sort our jobs, and compute $p(1),\dots,p(n)$ in $O(n)$ time. We then compute $OPT(j)$ linearly, only needing to compute $OPT(j)$ once.
\end{Func}

\begin{Func}[Backtracking Weighted Interval Scheduling - \textit{Backtrack()}]
    \vspace{-.5em}
    \begin{algorithm}[H]
        \SetAlgoLined
        \SetKwProg{Fn}{Function}{:}{}
        \tcp{$OPT[\ ]$ (optimal solutions of $j$ job) and $p()$ (next comptible job) are already computed for $1,\dots,j$}
        $j \gets OPT.length-1$; $S \gets \{\}$; \tcp{$S$ is our set of jobs}
        $Backtrack(OPT, j)$\;
        \Fn{\textit{Backtrack}(OPT, j)}{

                \If{$v_j+OPT[p(j)] > OPT[j-1]$}{
                    \Return $S \cup Backtrack(OPT, p(j))$\;
                }
                \Else{
                    \Return $Backtrack(OTP, j-1)$\;
                }

        }
    \end{algorithm}
    \noindent
    \rule{\textwidth}{0.4pt}
    \textbf{Correctness:} In our example above, the WIS's last index was the optimal solution. However, let $8=\$1$, then
    jobs $(6,1)$ would have been the optimal solution. This leaves $OPT[8]=\$19$, rather than $\$20$. Line 4 finds the first occurance where
    we found the optimal solution. As if we first found the optimal solution at index $6$, then $6,\dots,j$ would contain $OPT(6)$. This is why
    we exclude the choice $(7,3)=\$19$.\\

    \noindent
    We then repeat such pattern on the next compatible job. We know the set $N:=\{1\dots p(j)\}$ must contain an element of the optimal solution.
    Similar to our Dijkstra's proof (\ref{fig:dstra_proof}), that within the optimal path, a subpath's shortest path is also optimal. We check if
    $p(j)$ is the first occurance of the optimal solution in $N$, if not we continue to backtrack.\\

    \noindent
    \textbf{Time Complexity:} $O(n)$. At most, iterate through all $n$ jobs, and add them to our set $S$.
\end{Func}

\newpage

(\ref{func:subset})
\begin{Func}[Subset Sum - \textit{OPT()}]

    \vspace{-.5em}
    \begin{algorithm}[H]
        \SetAlgoLined
        \SetKwProg{Fn}{Function}{:}{}
        $S$; $T$; $OPT[\ ][\ ]$; \tcp{Set $S$, Weight ceiling $T$, DP table $OPT(i, T)$}
        $OPT[0][*] \gets 0$; \tcp{Base case (array of size $0$)}
        $OPT[*][0] \gets 0$; \tcp{Base case (array of size $T=0$)}
        \For{$i \gets 1$ \KwTo $S.length$}{
            \For{$t \gets 1$ \KwTo $T$}{
                
                \If{$S[i] > t$}{
                    $OPT[i][t] \gets OPT[i-1][t]$\;
                }
                \Else{
                    $OPT[i][t] \gets max\{\underbracket{OPT[i-1][t]}_{\text{next solution}}, \underbracket{S[i]+OPT[i-1][t-S[i]]}_{\text{build solution}}\}$\;
                }
            }
        }
        \textbf{return} $OPT$\;
    \end{algorithm}
    \noindent
    \rule{\textwidth}{0.4pt}
    \textbf{Time Complexity:} $O(nT)$. We iterate through all $n$ jobs, and for each job, we iterate through all $T$ target sums.
\end{Func}

\begin{Func}[Backtracking Subset Sum - \textit{Backtrack()}]

    \vspace{-.5em}
    \begin{algorithm}[H]
        \SetKwProg{Fn}{Function}{:}{}
        $i \gets 0$; $t \gets T$; $S \gets \{\}$; \tcp{$S$ is our set of jobs}
        $Backtrack(OPT, i, t)$\;
        \Fn{\textit{Backtrack}(OPT, i, t)}{
            \tcp{Where $OTP.length$ is the number of rows}
            \While{$i < OPT.length$}{
                \If{$OPT[i][t] > OPT[i+1][t]$}{
                    $S \gets S \cup \{S[i]\}$\;
                    $t \gets t-S[i]$\;
                }
                $i \gets i+1$\;
            }
            \Return $S$\;
        }
    \end{algorithm}
    \noindent
    \rule{\textwidth}{0.4pt}
    \textbf{Time Complexity:} $O(n)$. At most, iterate through all $n$ jobs, and add them to our set $S$.
\end{Func}

\newpage 

\noindent
Knapsack is skipped as it is similar to Subset Sum and Unbounded Knapsack (\ref{func:knapsack}). Below is the unoptimal version of Unbounded Knapsack (\ref{func:unbounded}).
    \begin{Func}[Unbounded Knapsack - \textit{UnboundedKnapsack()}]

        \vspace{-.5em}
        \begin{algorithm}[H]
            \SetKwProg{Fn}{Function}{:}{}
            $M \gets (n+1) \times (W+1)$ table \tcp{DP table}
            $C \gets (n+1) \times (W+1)$ table \tcp{Number of copies}
            $M[0][*] \gets 0$ and $M[*][0] \gets 0$\;
            
            \For{$i \gets 1$ \KwTo $n$}{
                \For{$w \gets 1$ \KwTo $W$}{
                    $M[i][w] \gets M[i-1][w]$; \tcp{Start with previous solution}
                    $m \gets 1$\;
                    
                    \While{$m \cdot w_i \leq w$}{
                        $val \gets m \cdot v_i + M[i-1][w - m \cdot w_i]$\;
                        \If{$val > M[i][w]$}{
                            $M[i][w] \gets val$\;
                            $C[i][w] \gets m$\;
                        }
                        $m \gets m + 1$\;
                    }
                }
            }
            \Return $M, C$\;
        \end{algorithm}
        
        \noindent
        \rule{\textwidth}{0.4pt}
        \textbf{Time Complexity:} $O(n \times W^2)$ \textbf{Space Complexity:} $O(n \times W)$
    \end{Func}
    \begin{Func}[Backtracking Unbounded Knapsack - \textit{BKBacktrack()}]

        \vspace{-.5em}
        \begin{algorithm}[H]
            \SetKwProg{Fn}{Function}{:}{}
            $sol \gets \emptyset$\;
            $i \gets n$ and $w \gets W$\;
            
            \While{$i > 0$ \textbf{and} $w > 0$}{
                $sol \gets sol \cup \{i \cdot C[i][w]\}$; \tcp{Add item $i$ with its count $C[i][w]$}
                $w \gets w - C[i][w] \cdot w_i$\;
                
                $i \gets i - 1$\;
            }
            
            \Return $sol$\;
        \end{algorithm}
        
        \noindent
        \rule{\textwidth}{0.4pt}
        \textbf{Time Complexity:} $O(n)$.
    \end{Func}
\newpage

(\ref{func:unbounded2})
\begin{Func}[Unbounded Knapsack - \textit{UnboundedKnapsack2()}]

    \vspace{-.5em}
    \begin{algorithm}[H]
        \SetKwProg{Fn}{Function}{:}{}
        $M \gets (n+1) \times (W+1)$ table$^*$ \tcp{DP table}
        $M[0][*] \gets 0$ and $M[*][0] \gets 0$ \tcp{Set first row and column to 0}
        
        \For{$i \gets 1$ \KwTo $n$}{
            \For{$w \gets 1$ \KwTo $W$}{
                \If{$w_i > w$}{
                    $M[i][w] \gets M[i-1][w]$;
                }
                \Else{
                    $val \gets v_i + M[i][w - w_i]$ \tcp{Take one more copy of $i$}
                    \If{$val > M[i-1][w]$}{
                        $M[i][w] \gets val$;
                    }
                    \Else{
                        $M[i][w] \gets M[i-1][w]$;
                    }
                }
            }
        }
        \Return $M$\;
    \end{algorithm}
    
    \noindent
    \rule{\textwidth}{0.4pt}
    \textbf{Time Complexity:} $O(n \times W)$.
\end{Func}

\begin{Func}[Traceback Solution for Unbounded Knapsack - \textit{Traceback()}]

    \vspace{-.5em}
    \begin{algorithm}[H]
        \SetKwProg{Fn}{Function}{:}{}
        $i \gets n$ \tcp{Start from the last item}
        $w \gets W$ \tcp{Start from the maximum weight}
        $sol \gets \emptyset$ \tcp{Initialize the solution set}
        
        \While{$i > 0$ \textbf{and} $w > 0$}{
            \If{$w \geq w_i$ \textbf{and} $(v_i + M[i][w - w_i] > M[i-1][w])$}{
                $sol.\textit{add}(i)$ \tcp{Add item $i$ to the solution}
                $w \gets w - w_i$ \tcp{Reduce the weight}
            }
            \Else{
                $i \gets i - 1$ \tcp{Move to the previous item}
            }
        }
        \Return $sol$\;
    \end{algorithm}
    
    \noindent
    \rule{\textwidth}{0.4pt}
    \textbf{Time Complexity:} $O(n + W)$.
\end{Func}
\newpage

