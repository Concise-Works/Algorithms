\subsection{Sequential Logic: Building Memory (RAM)}

\noindent
If we want to have a circuit that can \textbf{store} information, say ``Do $x$ if the previous input was $y$''
(E.g., traffic lights).

To start building intuition lets start by seeing what happens when we connect
gate outputs to other gate inputs in a loop, creating a \textbf{feedback loop} \cite{core_dumped_transistors}:
\begin{figure}[ht!]
  \centering
  \includegraphics[width=1\textwidth]{Sections/circuits/state/or_loop.png}
  \caption{A simple feedback loop using OR gates. 1) Initially both inputs are zero, then the free input
  is set to 1. 2) The output becomes 1, switching the feedback input to 1. 3) 
  Now even if the free input is set back to 0, the output remains 1, since one of the OR inputs is still 1.}
  \label{fig:or_loop}
\end{figure}

\begin{figure}[ht!]
  \centering
  \includegraphics[width=1\textwidth]{Sections/circuits/state/and_loop.png}
  \caption{A simple feedback loop using AND gates. 1) Initially both inputs are one, then the free input
  is set to 0. 2) The output becomes 0, switching the feedback input to 0. 3) 
  Now even if the free input is set back to 1, the output remains 0, since one of the AND inputs is still 0.}
  \label{fig:and_loop}
\end{figure}

\begin{figure}[ht!]
  \centering
  \includegraphics[width=1\textwidth]{Sections/circuits/state/combine_loop.png}
  \caption{Combining the OR and AND feedback loops from Figures (\ref{fig:or_loop}) and (\ref{fig:and_loop}),
  we get the above. 1) Initially both inputs are 0, output 0, then inputs both are set to 1, resulting in a a 1 output. 2) The output is now 1, and the first 
  input is set to 0, but the output remains 1, as the second input is still 1, driving the AND gate.}
  \label{fig:combine_loop}
\end{figure}

\newpage 
\noindent
In the above Figure (\ref{fig:combine_loop}), we can see that turning on the second input, effectively resets 
the output to 0. Lets see what happens when we keep the second input on with an inverter:

\begin{figure}[ht!]
  \centering
  \includegraphics[width=1\textwidth]{Sections/circuits/state/and_loop2.png}
  \caption{1) Initially all inputs are 0, output 0. 2) First input is set to 1,
  output becomes 1. 3) First input is set back to 0, but output remains 1. 
  4) Second input is set to 1, output becomes 0. 5) We characterize the first 
  input as the `SET' and the second input as the `RESET'.}
  \label{fig:sr_latch}
\end{figure}

\noindent
This circuit is called an:
\begin{Def}[AND-OR Latch]

    An \textbf{AND-OR Latch} is a basic memory element that can store one bit of information. 
    It has two inputs, labeled `S' (Set) and `R' (Reset), and a single output `Q'.

    However, this design has a critical flaw: if both `S' and `R' are set to 1 simultaneously creates an 
    \textbf{invalid state}, and the output hangs on 0, ignoring the 1 that's being ``set''.
\end{Def}

\noindent
Next we create a more sophisticated latch that avoids this invalid state.

\newpage 

\noindent
Let's work through improving the design of the AND-OR latch step by step:

\begin{figure}[ht!]
  \centering
  \includegraphics[width=1\textwidth]{Sections/circuits/state/gated_latch.png}
  \caption{1) We attempt to combine the SET and RESET lines to drive our `Data'; However, 
  this doesn't store information, as the output immediately follows the input.
  2) We introduce a `Write Enable' line. Now the data input only is written when we drive Write Enable high.
  3) Is the combinational logic we were abstracting---Test it out!}
  \label{fig:gated_latch}
\end{figure}

\begin{Def}[Gated Latch]

  A \textbf{Gated Latch} is a memory element that stores one bit of information. It has three inputs: `Data', `Write Enable', and a single output `Q'.
  When `Write Enable' is high, the value on the `Data' input is stored in the latch and reflected on the output `Q'.
\end{Def}

\newpage 

\noindent 
Let's do the same thing but with MUXs:
\begin{figure}[ht!]
  \centering
  \includegraphics[width=1\textwidth]{Sections/circuits/state/d_latch.png}
  \caption{1) Shows our MUX configuration. `Gate' selects which line to output: `Data' or $Q'$.
  Data contains incoming data, while $Q'$ is the feedback line (stores the last output). 2) Is an abstracted interface for what we call a \textbf{Data Latch} (D-Latch).
  \cite{terman2017computation_structures}}
  \label{fig:d_latch}
\end{figure}

\begin{Def}[Data Latch (D-Latch)]

  A \textbf{Data Latch} (D-Latch) is a memory element that stores one bit of information. It has one 
  select line `Gate', a `Data' input, a feedback input which store the last output value.
\end{Def}

\noindent 
Now we can build interesting circuits with combinational logic and memory:
\begin{Def}[Sequential Circuit]
   
  A \textbf{Sequential Circuit} combines combinational logic with memory devices (like D-Latches) to perform operations that depend on both current past inputs.
  The memory devices write enable line is often controlled by an oscillating clock signal (high and low). \cite{terman2017computation_structures}
\end{Def}

\begin{figure}[ht!]
  \centering
  \includegraphics[width=1\textwidth]{Sections/circuits/state/seq.png}
  \caption{A High-level idea of a sequential circuit; `LOAD' possibly controlled by a clock, `INPUT' perhaps a new button press.}
  \label{fig:sequential_circuit}
\end{figure}

\noindent
A new problem arises in this system. If the `LOAD' signal is high for too long, 
it may write multiple times, causing unintended behavior. 

Say we had a sequential circuit measures the average of the temperature outside:
Our `INPUT' a temperature reading, `LOAD' a clock that goes high every 30 minutes,
and our combinational logic averages the current reading with the stored reading.

\begin{figure}[ht!]
  \centering
  \includegraphics[width=1\textwidth]{Sections/circuits/state/temp.png}
  \caption{A sequential circuit that averages temperature readings every 30 minutes.}
  \label{fig:temp_seq}
  
\end{figure}